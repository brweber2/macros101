Reader - Evaluator

Reader - uses Pushback reader to read source file one char at a time and return Lisp data structures

  what can you read?
    strings (as in ")
    comments (as in ;)
    quotes (as in ')
    derefs (as in @)
    meta (as in ^)
    macro related stuff:
      syntax quotes (as in `)
      unquote (as in ~)
        unquote splicing (as in ~@)
    lists (as in ()
    vectors (as in [)
    maps (as in {)
    characters (as in \)
    arg reader (as in %) ; as in argument %2
    
    READER MACROS
    dispatch reader (as in #)
      meta (#^)
      var (#')
      regex (#")
      anonymous fn (#()
      sets (#{)
      eval (#=)
      comment (#!)
      unreadable (#<) ; throws an exception, not very useful!
      discard (#_)
    


Evaluator - instead of interpreting, compiles and runs the generated byte code

As part of this, take a data structure as an input and transform it to another data structure.
This is the purpose of a macro.  Macros can call other macros or be recursive.  Macros are
resolved until no macros remain and only data structures are left.  These data structures are
then compiled to byte code and executed.

Line 5865 of Compiler has compile method.  It compiles a new class with a static load method.  
The contents of the load method is the compiled clojure code. 
There are static fields for constants and a static <clinit> clojure
constructor.

Uses object web ASM byte code library for generating the java byte code.

Line 5841 of Compiler.java contains what we are looking for today.  The macroexpand that
occurs during compilation.  Line 5181 is macroexpand-1.

